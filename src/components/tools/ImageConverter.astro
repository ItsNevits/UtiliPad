---
import BoxIcon from "@assets/icons/box.svg";
import Image from "astro/components/Image.astro";

interface Props {
  t: any;
}

const { t } = Astro.props;
---

<div class="bg-neutral-800/50 rounded-xl p-6 select-none mb-5">
  <div
    id="drop-zone"
    class="border border-neutral-700 p-5 rounded flex flex-col items-center justify-center cursor-pointer"
  >
    <Image
      class="text-neutral-400 mb-2 svg-color-neutral-400 opacity-40"
      src={BoxIcon}
      alt={"Box icon"}
      quality={"mid"}
      width={35}
      height={35}
      loading={"lazy"}
    />
    <span class="text-neutral-400">{t.components.imageConverter.dropFiles}</span
    >
    <input
      type="file"
      class="hidden"
      id="images-file-input"
      multiple
      accept="image/*"
    />
  </div>
</div>

<div
  id="files-uploaded"
  class="bg-neutral-800/50 rounded-xl p-6 select-none mb-5 hidden relative"
>
  <div
    id="overlay-image-files"
    class="absolute top-0 left-0 w-full h-full bg-gray-900/50 items-center justify-center z-10 hidden"
  >
    <p class="text-lg md:text-xl font-bold leading-tight animate-bounce">
      {t.components.imageConverter.processInfo || "Processing..."}
    </p>
  </div>
  <div class="flex items-end justify-between mb-4">
    <h2 class="text-xl md:text-2xl font-bold leading-tight">
      {t.components.imageConverter.filesUploaded}
    </h2>
    <span class="text-neutral-400 text-sm">
      {t.components.imageConverter.totalFiles}: <span id="total-files-uploaded"
        >0</span
      >
    </span>
  </div>
  <div
    id="content-files-uploaded"
    class="relative flex flex-col gap-4 max-h-100 overflow-y-auto mb-4"
  >
  </div>
  <div class="flex flex-wrap items-center justify-between gap-2">
    <button
      id="compress-and-download"
      class="cursor-pointer mt-5 px-4 py-2 bg-neutral-700 hover:bg-neutral-600 text-neutral-200 rounded transition-colors text-sm"
    >
      {t.general.downloadZip}
    </button>

    <div class="flex items-center gap-2">
      <label for="all-images">{t.general.all}:</label>
      <select
        name="all-images"
        id="all-images"
        class="cursor-pointer px-3 py-1 bg-neutral-900/60 border border-neutral-700 rounded text-neutral-200 focus:outline-none focus:ring-2 focus:ring-emerald-500/50 focus:border-emerald-500/50"
        onchange="window.changeAllImageFormats(this.value)"
      >
        <option value="" selected disabled>{t.general.select}</option>
        <option value="jpeg">JPEG</option>
        <option value="png">PNG</option>
        <option value="webp">WEBP</option>
        <option value="tiff">TIFF</option>
        <option value="avif">AVIF</option>
      </select>
    </div>
  </div>
</div>

<astro-greet data-translations={JSON.stringify(t.general)}></astro-greet>

<script>
  // Cambia todos los selects de formato de imagen al valor global
  (window as any).changeAllImageFormats = function (format: string) {
    if (!format) return;
    currentFiles.forEach((_, idx) => {
      const select = document.getElementById(
        `format-select-${idx}`
      ) as HTMLSelectElement | null;
      if (select) select.value = format;
    });
  };

  const outputFormats = ["jpg", "jpeg", "png", "webp", "tiff", "avif"];

  let jsonMessages = {} as any;

  class AstroGreet extends HTMLElement {
    connectedCallback() {
      const t = JSON.parse(this.getAttribute("data-translations") || "{}");
      jsonMessages = t || {};
    }
  }

  customElements.define("astro-greet", AstroGreet);

  const dropZone = document.getElementById(
    "drop-zone"
  ) as HTMLDivElement | null;
  const fileInput = document.getElementById(
    "images-file-input"
  ) as HTMLInputElement | null;
  const filesUploaded = document.getElementById(
    "files-uploaded"
  ) as HTMLDivElement | null;
  const contentFilesUploaded = document.getElementById(
    "content-files-uploaded"
  ) as HTMLDivElement | null;
  const compressButton = document.getElementById(
    "compress-and-download"
  ) as HTMLButtonElement | null;
  const overlay = document.getElementById(
    "overlay-image-files"
  ) as HTMLDivElement | null;

  let currentFiles: File[] = [];

  if (dropZone && fileInput) {
    dropZone.addEventListener("click", () => {
      fileInput.click();
    });

    dropZone.addEventListener("dragover", (event) => {
      event.preventDefault();
      dropZone.classList.add("border-blue-500");
    });

    dropZone.addEventListener("dragleave", () => {
      dropZone.classList.remove("border-blue-500");
    });

    dropZone.addEventListener("drop", (event: DragEvent) => {
      event.preventDefault();
      dropZone.classList.remove("border-blue-500");
      if (!event.dataTransfer) return;
      const files = event.dataTransfer.files;
      handleFiles(files);
    });
  }

  if (fileInput) {
    fileInput.addEventListener("change", () => {
      const files = fileInput.files;
      handleFiles(files);
    });
  }

  function handleFiles(files: FileList | null) {
    if (!files || files.length === 0) return;
    const newFiles = Array.from(files);
    currentFiles = [...currentFiles, ...newFiles];
    updateUI();
  }

  function updateUI() {
    if (!filesUploaded || !contentFilesUploaded) return;
    if (currentFiles.length === 0) {
      filesUploaded.classList.add("hidden");
      return;
    }
    filesUploaded.classList.remove("hidden");
    contentFilesUploaded.innerHTML = "";
    currentFiles.forEach((file: File, index: number) => {
      const fileType = file.name.split(".").pop() || "file";

      // Solo permitir tipos de imagen comunes
      if (outputFormats.includes(fileType.toLowerCase()) === false) return;

      const fileName = file.name;
      const fileSize = (file.size / 1024).toFixed(2) + " KB";
      const newElement = generateElement(fileType, fileName, fileSize, index);
      contentFilesUploaded.appendChild(
        document.createRange().createContextualFragment(newElement)
      );
    });
    const totalFilesSpan = document.getElementById(
      "total-files-uploaded"
    ) as HTMLSpanElement | null;
    if (totalFilesSpan) {
      totalFilesSpan.textContent = currentFiles.length.toString();
    }
    updateFileInput();
  }

  function updateFileInput() {
    if (!fileInput) return;
    const dt = new DataTransfer();
    currentFiles.forEach((file) => dt.items.add(file));
    fileInput.files = dt.files;
  }

  function generateElement(
    type: string,
    name: string,
    size: string,
    index: number
  ): string {
    return `
      <div class="bg-neutral-900/40 rounded-2xl border border-neutral-800 p-4 flex flex-col gap-4 justify-between">
        <div class="flex flex-col md:flex-row md:items-center gap-4 justify-between flex-wrap">
          <div class="flex items-center gap-4 flex-1 min-w-0">
            <div class="w-10 min-w-10 h-10 min-h-10 bg-neutral-700/50 rounded flex items-center justify-center">
              <span class="text-sm text-neutral-400">${type.toUpperCase()}</span>
            </div>
            <div class="min-w-0">
              <p class="font-medium truncate max-w-[180px] md:max-w-[300px] lg:max-w-[400px] xl:max-w-[600px]" title="${name}">${name}</p>
              <p class="text-sm text-neutral-400">${size}</p>
            </div>
          </div>
          <div class="flex items-center gap-2">
            <label for="format-select-${index}">${jsonMessages.format}:</label>
            <select class="cursor-pointer px-3 py-1 bg-neutral-900/60 border border-neutral-700 rounded text-neutral-200 focus:outline-none focus:ring-2 focus:ring-emerald-500/50 focus:border-emerald-500/50 w-full md:w-auto" id="format-select-${index}">
              <option value="" disabled selected>${jsonMessages.select}</option>
              ${outputFormats
                .filter((f) => f !== "jpg")
                .map((f) => `<option value="${f}">${f.toUpperCase()}</option>`)
                .join("")}
            </select>
          </div>
        </div>
        <div class="flex items-center gap-3 flex-wrap w-full md:w-auto">
          <button class="cursor-pointer min-w-25 px-3 py-1 bg-neutral-700 hover:bg-neutral-600 text-neutral-200 rounded transition-colors text-sm w-full md:w-auto" onclick="window.downloadImage(${index})">
            ${jsonMessages.download}
          </button>
          <button title="${jsonMessages.delete}" class="cursor-pointer min-w-25 px-3 py-1 bg-red-600/20 hover:bg-red-600/30 text-red-400 rounded transition-colors text-sm w-full md:w-auto" onclick="window.removeFileUploaded(${index})">
            ${jsonMessages.delete}
          </button>
        </div>
      </div>
    `;
  }

  function removeFileUploaded(index: number) {
    currentFiles.splice(index, 1);
    updateUI();
  }

  (window as any).removeFileUploaded = removeFileUploaded;

  // Placeholder for downloadImage (to be implemented with API/sharp)
  (window as any).downloadImage = async function (index: number) {
    const file = currentFiles[index];
    if (!file) return;

    const formatSelect = document.getElementById(
      `format-select-${index}`
    ) as HTMLSelectElement | null;

    const format = formatSelect?.value || "jpeg";

    if (!format) {
      alert(jsonMessages.selectFormat || "Selecciona un formato");
      return;
    }

    try {
      if (overlay) {
        overlay.classList.remove("hidden");
        overlay.classList.add("flex");
      }

      const formData = new FormData();
      formData.append("file", file);
      formData.append("format", format);

      const response = await fetch("/api/images/convert", {
        method: "POST",
        body: formData,
      });

      if (!response.ok) {
        const errorText = await response.text();
        throw new Error(errorText);
      }

      const outputBuffer = await response.arrayBuffer();
      const blob = new Blob([outputBuffer], { type: `image/${format}` });
      const url = URL.createObjectURL(blob);
      const a = document.createElement("a");

      a.href = url;
      a.download = `${file.name.split(".")[0]}.${format}`;
      document.body.appendChild(a);
      a.click();

      document.body.removeChild(a);
      URL.revokeObjectURL(url);
    } catch (err: any) {
      alert(
        jsonMessages.downloadNotImplemented ||
          "Error al convertir la imagen: " + err.message
      );
    } finally {
      // Ocultar overlay o manejar estado si es necesario
      if (overlay) {
        overlay.classList.add("hidden");
        overlay.classList.remove("flex");
      }
    }
  };

  if (compressButton) {
    compressButton.addEventListener("click", compressAndDownload);
  }

  async function compressAndDownload() {
    if (currentFiles.length === 0) return;

    if (overlay) {
      overlay.classList.remove("hidden");
      overlay.classList.add("flex");
    }

    try {
      // Obtener formatos seleccionados para cada archivo
      const formats = currentFiles.map((_, idx) => {
        const select = document.getElementById(
          `format-select-${idx}`
        ) as HTMLSelectElement | null;
        return select && select.value ? select.value : "jpeg";
      });

      const formData = new FormData();
      currentFiles.forEach((file, idx) => {
        formData.append("files[]", file, file.name);
        formData.append("formats[]", formats[idx]);
      });

      formData.append("asZip", "true");

      if (overlay) {
        overlay.classList.remove("hidden");
        overlay.classList.add("flex");
      }

      const response = await fetch("/api/images/convert", {
        method: "POST",
        body: formData,
      });

      if (!response.ok) {
        const errorText = await response.text();
        throw new Error(errorText);
      }

      const zipBuffer = await response.arrayBuffer();
      const blob = new Blob([zipBuffer], { type: "application/zip" });
      const url = URL.createObjectURL(blob);
      const a = document.createElement("a");

      a.href = url;
      a.download = "images.zip";
      document.body.appendChild(a);
      a.click();

      document.body.removeChild(a);
      URL.revokeObjectURL(url);
    } catch (err: any) {
      alert(
        jsonMessages.downloadAllNotImplemented ||
          "Error al comprimir y descargar: " + err.message
      );
    } finally {
      // Ocultar overlay o manejar estado si es necesario
      if (overlay) {
        overlay.classList.add("hidden");
        overlay.classList.remove("flex");
      }
    }
  }
</script>
