---
import type { Language } from "@/types/language.type";
import { getTranslation } from "@/i18n/index";

const lang = Astro.params.lang as Language;
---

<div class="relative w-full max-w-md">
  <label class="relative block">
    <input
      id="search-input"
      placeholder={getTranslation(lang, "components.search.placeholder")}
      class="w-full rounded-xl bg-white/80 border border-neutral-300 px-4 py-2.5 text-sm text-neutral-700 placeholder:text-neutral-500 focus:outline-none focus:ring-2 focus:ring-emerald-500/50 focus:border-emerald-500 transition-all shadow-sm"
      autocomplete="off"
    />
    <span
      id="keyboard-shortcut"
      class="absolute right-3 top-1/2 -translate-y-1/2 text-xs font-medium text-neutral-400 bg-neutral-100 px-2 py-0.5 rounded border border-neutral-300"
      >Ctrl + K</span
    >
  </label>

  <!-- Resultados de búsqueda -->
  <div
    id="search-results"
    class="absolute top-full left-0 right-0 mt-2 bg-white border border-neutral-200 rounded-xl shadow-lg z-50 max-h-96 overflow-y-auto hidden"
  >
    <div class="p-3">
      <div
        class="text-xs font-medium text-neutral-500 mb-2 uppercase tracking-wide"
      >
        {getTranslation(lang, "components.search.results")}
      </div>
      <div id="results-container">
        <!-- Los resultados se insertan aquí -->
      </div>
      <div
        id="no-results"
        class="text-sm text-neutral-600 text-center py-8 hidden"
      >
        {getTranslation(lang, "components.search.noResults")}
      </div>
    </div>
  </div>
</div>

<script>
  import { actions } from "astro:actions";

  // Función de búsqueda que llama a la action del servidor
  async function searchTools(query: string, lang: string) {
    try {
      const { data, error } = await actions.searchTools({
        query,
        lang: lang as "es" | "en",
      });

      if (error) {
        console.error("Search error:", error);
        return [];
      }

      return data?.results || [];
    } catch (err) {
      console.error("Search failed:", err);
      return [];
    }
  }

  function initializeSearch() {
    const searchInput = document.getElementById("search-input");
    const searchResults = document.getElementById("search-results");
    const resultsContainer = document.getElementById("results-container");
    const noResults = document.getElementById("no-results");
    const keyboardShortcut = document.getElementById("keyboard-shortcut");

    // Si no se encuentran los elementos, salir
    if (!searchInput || !searchResults || !resultsContainer || !noResults) {
      return;
    }

    // Obtener el idioma del path actual
    const lang = window.location.pathname.split("/")[1] || "es";

    // Detectar el sistema operativo y actualizar el shortcut
    const isMac =
      /Mac|iPhone|iPod|iPad/.test(navigator.platform) ||
      /Mac|iPhone|iPod|iPad/.test(navigator.userAgent);

    if (keyboardShortcut) {
      keyboardShortcut.textContent = isMac ? "⌘ + K" : "Ctrl + K";
    }

    let currentIndex = -1; // Índice del resultado seleccionado
    let currentResults: any[] = []; // Resultados actuales
    let debounceTimer: number | null = null; // Timer para el debounce

    // Función para renderizar los resultados
    function renderResults(tools: any[]) {
      if (!resultsContainer || !noResults) return;

      currentResults = tools;
      currentIndex = -1; // Reset del índice

      if (tools.length === 0) {
        resultsContainer.innerHTML = "";
        noResults.classList.remove("hidden");
        return;
      }

      noResults.classList.add("hidden");
      resultsContainer.innerHTML = tools
        .map(
          (tool, index) => `
        <a
          href="${tool.href}"
          data-index="${index}"
          class="result-item block p-3 rounded-lg hover:bg-neutral-100 transition-colors border-b border-neutral-100 last:border-b-0 focus:outline-none focus:bg-neutral-100"
          tabindex="-1"
        >
          <div class="font-semibold text-sm text-neutral-800">${tool.name}</div>
          <div class="text-xs text-neutral-600 mt-1 line-clamp-2">${tool.description}</div>
        </a>
      `
        )
        .join("");
    }

    // Función para actualizar la selección visual
    function updateSelection() {
      if (!resultsContainer) return;

      const items = resultsContainer.querySelectorAll(".result-item");
      items.forEach((item, index) => {
        if (index === currentIndex) {
          item.classList.add("bg-neutral-100");
          item.classList.remove("hover:bg-neutral-100");
        } else {
          item.classList.remove("bg-neutral-100");
          item.classList.add("hover:bg-neutral-100");
        }
      });
    }

    // Función para navegar a la opción seleccionada
    function navigateToSelected() {
      if (currentIndex >= 0 && currentIndex < currentResults.length) {
        const selectedTool = currentResults[currentIndex];
        window.location.href = selectedTool.href;
      }
    }

    // Función para realizar la búsqueda con debounce
    function debouncedSearch(query: string) {
      // Limpiar el timer anterior
      if (debounceTimer !== null) {
        clearTimeout(debounceTimer);
      }

      // Si el query está vacío, ocultar resultados inmediatamente
      if (query.trim().length === 0) {
        if (searchResults) {
          searchResults.classList.add("hidden");
        }
        return;
      }

      // Mostrar resultados con indicador de carga
      if (resultsContainer && searchResults) {
        resultsContainer.innerHTML = `
          <div class="text-center py-4">
            <div class="animate-pulse text-neutral-500 text-sm">Buscando...</div>
          </div>
        `;
        searchResults.classList.remove("hidden");
      }

      // Establecer un nuevo timer
      debounceTimer = window.setTimeout(() => {
        performSearch(query);
      }, 300); // Esperar 300ms después de que el usuario deje de escribir
    }

    // Función para realizar la búsqueda
    async function performSearch(query: string) {
      if (!resultsContainer || !searchResults) return;

      const results = await searchTools(query, lang);
      renderResults(results);
    }

    // Event listeners
    searchInput.addEventListener("input", (e) => {
      const query = (e.target as HTMLInputElement).value;
      debouncedSearch(query);
    });

    // Agregar evento change para compatibilidad móvil (solo en móviles)
    searchInput.addEventListener("change", (e) => {
      // Solo procesar en dispositivos móviles para evitar conflictos
      if ("ontouchstart" in window) {
        const query = (e.target as HTMLInputElement).value;
        debouncedSearch(query);
      }
    });

    // Agregar eventos adicionales para mejor soporte móvil
    searchInput.addEventListener("keyup", (e) => {
      // Ignorar teclas de navegación
      const navigationKeys = ["ArrowDown", "ArrowUp", "Tab", "Enter", "Escape"];
      if (navigationKeys.includes(e.key)) {
        return;
      }

      const query = (e.target as HTMLInputElement).value;
      debouncedSearch(query);
    });

    searchInput.addEventListener("paste", (e) => {
      // Usar setTimeout para esperar que el paste se complete
      setTimeout(() => {
        const query = (searchInput as HTMLInputElement).value;
        debouncedSearch(query);
      }, 10);
    });

    // Cerrar resultados al hacer clic fuera
    document.addEventListener("click", (e) => {
      const target = e.target as Node;
      if (!searchResults.contains(target) && target !== searchInput) {
        searchResults.classList.add("hidden");
      }
    });

    // Mostrar resultados al hacer focus si hay contenido
    searchInput.addEventListener("focus", () => {
      if ((searchInput as HTMLInputElement).value.trim().length > 0) {
        searchResults.classList.remove("hidden");
      }
    });

    // Navegación con teclado en el input de búsqueda
    searchInput.addEventListener("keydown", (e) => {
      const isResultsVisible = !searchResults.classList.contains("hidden");

      // Manejar Escape siempre
      if (e.key === "Escape") {
        e.preventDefault();
        searchResults.classList.add("hidden");
        currentIndex = -1;
        return;
      }

      // Solo procesar navegación si hay resultados visibles
      if (!isResultsVisible || currentResults.length === 0) return;

      switch (e.key) {
        case "ArrowDown":
          e.preventDefault();
          e.stopPropagation();
          currentIndex =
            currentIndex < currentResults.length - 1 ? currentIndex + 1 : 0;
          updateSelection();
          break;

        case "ArrowUp":
          e.preventDefault();
          e.stopPropagation();
          currentIndex =
            currentIndex > 0 ? currentIndex - 1 : currentResults.length - 1;
          updateSelection();
          break;

        case "Tab":
          if (!e.shiftKey) {
            e.preventDefault();
            e.stopPropagation();
            currentIndex =
              currentIndex < currentResults.length - 1 ? currentIndex + 1 : 0;
            updateSelection();
          } else {
            e.preventDefault();
            e.stopPropagation();
            currentIndex =
              currentIndex > 0 ? currentIndex - 1 : currentResults.length - 1;
            updateSelection();
          }
          break;

        case "Enter":
          e.preventDefault();
          e.stopPropagation();
          navigateToSelected();
          break;
      }
    });

    // Atajo de teclado (/ y Ctrl+K / Cmd+K) para enfocar la búsqueda
    document.addEventListener("keydown", (e) => {
      // Ctrl+K (Windows/Linux) o Cmd+K (Mac)
      if (
        e.key === "k" &&
        (e.ctrlKey || e.metaKey) &&
        !searchInput.matches(":focus")
      ) {
        e.preventDefault();
        searchInput.focus();
        (searchInput as HTMLInputElement).select();
      }

      if (e.key === "/" && !searchInput.matches(":focus")) {
        e.preventDefault();
        searchInput.focus();
      }

      // ESC para cerrar resultados (global)
      if (e.key === "Escape") {
        searchResults.classList.add("hidden");
        searchInput.blur();
        currentIndex = -1;
      }
    });

    // Click en los resultados para seleccionar con mouse
    resultsContainer.addEventListener("mouseover", (e) => {
      const target = e.target as HTMLElement;
      const resultItem = target.closest(".result-item") as HTMLElement;

      if (resultItem && resultItem.dataset.index) {
        const index = parseInt(resultItem.dataset.index || "-1");
        if (index >= 0) {
          currentIndex = index;
          updateSelection();
        }
      }
    });
  }

  // Inicializar cuando el DOM esté listo
  document.addEventListener("DOMContentLoaded", initializeSearch);
</script>
